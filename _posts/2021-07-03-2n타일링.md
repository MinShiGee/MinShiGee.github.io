---
title: "Log17: pmrs - 2*n 타일링"
categories:
  - devLog
  - PS
  - Python
---
## Programmers - 2*n 타일링

```
code link: https://github.com/MinShiGee/problem-solving-codes/blob/master/pmrs-2n%ED%83%80%EC%9D%BC%EB%A7%81.py
problem link: https://programmers.co.kr/learn/courses/30/lessons/12900
```

#### O(N) 풀이법
기본적인 dp 문제로 피보나치 수열과 같은 공식에 기저만 바꾸면 답을 얻을 수 있다.
> f(n) = 길이가 n인 사각형을 타일로 채우는 경우의 수

> f(n) = f(n-1) + f(n-2) if f(1) = 1, f(2) = 2

위의 식으로 매우 간단하게 답을 구할 수 있다. (나머지 연산은 매 연산마다 해주면 된다.)

그런데 위의 방식은 이미 dp를 처음 배울 때 해봤던 것이고, 파이썬으로 풀 때는 뭔가 더 멋진 알고리즘? 코드로 풀어보고 싶었다. 데이터를 저장하지 않는다면 사이즈가 3인 리스트로도 충분히 구현할 수 있다.

>결론적으로 위의 일반적인 풀이는 메모리는 최대 거의 0에 가깝게 사용하며 시간 복잡도는 O(N)인 풀이가 된다.

#### O(logN) 풀이법
그렇다면 다른 풀이법은 어떤게 있을까?

> 'n / 2개의 타일을 채우는 경우의 곱으로 구할 수 있지 않을까?'

라는 아이디어를 가지고 문제에 접근을 해봤다. 즉 f(n) = f(n / 2) * f(n / 2)로 푸는 것인데, 짝수와 홀수를 나누어 구분하면 다음과 같다.
> f(n) = f(n / 2) * f(n / 2) if (n % 2 == 0)

> f(n) = f(n / 2 + 1) * f(n / 2) if (n % 2 == 1)

하지만 위의 방식으로 문제를 풀면 오답이 나오는데, 그 이유는 타일 중에 가로로 채워지는 타일이 n / 2 크기 사각형 사이에 위치하는 경우를 처리하지 못하기 때문이다. 따라서 그 조건을 고려하면 다음과 같은 식을 만들 수 있다.
> f(n) = f(n / 2) * f(n / 2) + f(n / 2 - 1) * f(n / 2 - 1) if (n % 2 == 0)

> f(n) = f(n / 2 + 1) * f(n / 2) + f(n / 2) * f(n / 2 - 1) if (n % 2 == 1)

n / 2 사각형 사이에 누워서 발생하는 경우를 따로 구해서 더해주면 정답인 식을 구할 수 있다. 이제 우리가 구한 식에 대한 기저사례를 구해야한다. 기저는 식에서 참조하는 경우의 수가 3개이니 결과적으로 f(1), f(2), f(3)만 메모이제이션 테이블에 넣어주면 답을 구할 수 있다.

테이블같은 경우는 리스트로 구현해도 괜찮다. 그런데 파이썬은 사용하기 편한 딕셔너리를 기본적으로 가지고 있으니, 이를 이용해서 구현해주면 방문한 n에 대한 내용만 메모가 이루어지므로 메모리도 아낄 수 있다.

> 위의 방식을 재귀로 참조하면서 메모이제이션을 걸어주면 시간복잡도는 O(logN)이며 사용하는 메모리의 크기도 그만큼 아낄 수 있다. (참조한 크기만큼만 딕셔너리에 추가함으로 사실상 logN * 3? 정도가 될 것 같다.)

### Code...

```
tmp = 1000000007

def f(n:int, dic:dict):
    global tmp
    if n in dic:
        return dic[n]
    res = 0
    if n % 2 == 1:
        res = f(n//2 + 1, dic) * f(n//2, dic) % tmp + f(n//2, dic) * f(n//2 -1, dic) % tmp
    else:
        res = f(n//2, dic) * f(n//2, dic) % tmp + f(n//2 - 1, dic) * f(n//2 -1, dic) % tmp
    res %= tmp
    dic[n] = res
    return dic[n]

def solution(n):
    dp_dic = {0:0, 1:1, 2:2, 3:3}
    answer = f(n, dp_dic)
    return answer
```