---
title: "Log09: pmrs - 가장 큰 수"
categories:
  - devLog
  - PS
  - Python
---
## Programmers - 가장 큰 수

```

code link: https://github.com/MinShiGee/problem-solving-codes/blob/master/pmrs-%EA%B0%80%EC%9E%A5%ED%81%B0%EC%88%98.py
problem link: https://programmers.co.kr/learn/courses/30/lessons/42746

```
처음 이 문제를 봤을 때, 그냥 str형태로 정렬을 한 후 합치면 정답이 나오지 않을까 생각했다.

위의 방법으로만 코드를 작성하면 다음과 같은 문제와 만날 수 있었다.
> * '3'과 '330'와 같이 일반 정렬로는 오답이 나오는 경우 

막상 적으니 위의 문제가 전부인 것 같다.

이 문제를 해결하기 위해서는 정렬 과정에 조건을 넣어주는 방법이 가장 쉬운 방법이었다. 그 조건을 어떻게 정해야 할지가 조금 고민이었는데, 문제 입력조건이 그냥 1000이하의 정수로 이루어진 list라는 것을 보니 바로 정할 수 있었다.

일단 처음 문제를 보고 떠올린 방법은 비교하는 v1, v2가 있으면 v1 + v2, v2 + v1을 비교해서 더 큰쪽의 먼저 나오는 인자가 더 크다는 식으로 비교하는 방법이었다. 그런데 파이썬의 sorted()함수에서 key 인수를 이용해 그런 방법을 구현하는 것은 아직 파이썬에 익숙치않은 내가 하기에는 조금 귀찮은 작업이었다(~~정렬을 직접 구현해서 쓰는거면 모르겠는데 sorted(key=...)으로는 입력값들의 조합들을 튜플로 넣어주는 코드 말곤 떠오르지가 않는다.~~).

결론적으로 그냥 value를 * 5를 해주는 방법을 선택했다. '3'과 '32', '332'등을 '333232'로 만든다고 가정해보자. 다행히도 문제의 입력조건에 제한이 걸려있는데, 그 덕분에 4자리 이하에서 중복? 포함되는 관계에서의 정렬만 신경써주면 된다. *5를 해주면 '33333', '32323..','332332...'끼리 비교하게 될 것이고 결론적으로 포함으로 인해 생기는 문제는 모두 해결할 수 있다.

그런데 마지막 케이스가 자꾸 오답이 나왔다. 혹시나 내가 예상하지 못한 극단적은 경우가 있는지 엄청 고민했는데, 그냥 [0,0,0] 으로 들어오면 '000'이 아니라 '0'으로 출력해야하는 사실을 간과했었다. 크흠... 아래는 결과적으로 정답이 뜬 코드다.

```
def solution(numbers):
    res = ''.join(sorted([str(data) for data in numbers], key=lambda x: x*5, reverse=True))
    if res[0] == '0':
        res = '0'
    return res
```